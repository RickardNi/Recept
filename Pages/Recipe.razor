@page "/recipe/{slug}"
@using Markdig
@using System.Text.RegularExpressions
@inject HttpClient Http

<PageTitle>@pageTitle</PageTitle>

@if (isLoading)
{
    <p>Laddar recept...</p>
}
else if (errorMessage != null)
{
    <h3>Hoppsan!</h3>
    <p>@errorMessage</p>
    <p><a href="/">Tillbaka till startsidan</a></p>
}
else
{
    <article class="recipe">
        <div class="recipe-header">
            <h1>@recipeTitle</h1>
            @((MarkupString)preIngredientsHtml)
        </div>
        <div class="recipe-body">
            <aside class="recipe-ingredients">
                @((MarkupString)ingredientsHeadingHtml)
                @if (!string.IsNullOrEmpty(ingredientsListHtml))
                {
                    <div class="portion-control">
                        <button class="portion-btn" @onclick="DecrementServings" disabled="@(currentServings <= 1)">−</button>
                        <select value="@currentServings" @onchange="OnServingsSelectChanged">
                            @for (int i = 1; i <= 12; i++)
                            {
                                <option value="@i">@i @(i == 1 ? "portion" : "portioner")</option>
                            }
                        </select>
                        <button class="portion-btn" @onclick="IncrementServings" disabled="@(currentServings >= 12)">+</button>
                    </div>
                }
                @((MarkupString)scaledIngredientsListHtml)
            </aside>
            <div class="recipe-content">
                @((MarkupString)scaledPostIngredientsHtml)
            </div>
        </div>
    </article>
}

@code {
    private static readonly MarkdownPipeline pipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .Build();

    [Parameter]
    public string Slug { get; set; } = string.Empty;

    private string preIngredientsHtml = string.Empty;
    private string ingredientsHeadingHtml = string.Empty;
    private string ingredientsListHtml = string.Empty;
    private string scaledIngredientsListHtml = string.Empty;
    private string rawPostIngredientsHtml = string.Empty;
    private string scaledPostIngredientsHtml = string.Empty;
    private string recipeTitle = string.Empty;
    private string pageTitle = "Recept";
    private bool isLoading = true;
    private string? errorMessage = null;
    private int defaultServings = 1;
    private int currentServings = 1;

    protected override async Task OnParametersSetAsync()
    {
        await LoadRecipe();
    }

    private async Task LoadRecipe()
    {
        isLoading = true;
        errorMessage = null;

        try
        {
            // Construct the path to the markdown file
            var markdownPath = $"recipes/{Slug}.md";

            // Fetch the markdown content
            var markdown = await Http.GetStringAsync(markdownPath);

            // Strip YAML frontmatter and extract title
            var markdownWithoutFrontmatter = markdown;
            var frontmatterMatch = Regex.Match(markdown, @"^---\s*\n(.*?)\n---\s*\n", RegexOptions.Singleline);

            if (frontmatterMatch.Success)
            {
                // Extract title from frontmatter
                var frontmatter = frontmatterMatch.Groups[1].Value;
                var titleMatch = Regex.Match(frontmatter, @"title:\s*[""'](.+?)[""']");
                if (titleMatch.Success)
                {
                    recipeTitle = titleMatch.Groups[1].Value;
                    pageTitle = recipeTitle + " - Recept";
                }

                // Extract default servings
                var servingsMatch = Regex.Match(frontmatter, @"servings:\s*(\d+)");
                if (servingsMatch.Success && int.TryParse(servingsMatch.Groups[1].Value, out var s))
                {
                    defaultServings = s;
                    currentServings = s;
                }

                // Remove frontmatter from markdown
                markdownWithoutFrontmatter = markdown.Substring(frontmatterMatch.Length);
            }

            // Fallback: extract first H1 if no frontmatter title
            if (string.IsNullOrEmpty(recipeTitle))
            {
                var h1Match = Regex.Match(markdownWithoutFrontmatter, @"^#\s+(.+)$", RegexOptions.Multiline);
                if (h1Match.Success)
                {
                    recipeTitle = h1Match.Groups[1].Value.Trim();
                    pageTitle = recipeTitle + " - Recept";
                    // Remove the H1 from markdown since we'll display it separately
                    markdownWithoutFrontmatter = Regex.Replace(markdownWithoutFrontmatter, @"^#\s+.+$", "", RegexOptions.Multiline).TrimStart();
                }
                else
                {
                    recipeTitle = Slug.Replace("-", " ");
                    pageTitle = recipeTitle + " - Recept";
                }
            }

            // Convert markdown to HTML using Markdig
            var fullHtml = Markdown.ToHtml(markdownWithoutFrontmatter, pipeline);

            // Make task-list checkboxes interactive (Markdig marks them disabled)
            fullHtml = fullHtml.Replace("disabled=\"disabled\" type=\"checkbox\"", "type=\"checkbox\"");

            // Inject unique ids + matching <label class="step-circle"> elements so the
            // CSS :checked + label sibling selector works and step numbers show in circles.
            fullHtml = InjectStepCircleLabels(fullHtml);

            // Split HTML into pre-ingredients, the ingredients section, and post-ingredients.
            // The ingredients section is the <h2>Ingredienser</h2> block up to (not including)
            // the next <h2> or end of content.
            var ingredientsSplit = Regex.Match(
                fullHtml,
                @"(?s)(<h2[^>]*>\s*Ingredienser\s*</h2>.*?)(?=<h2[\s>]|$)",
                RegexOptions.IgnoreCase);

            if (ingredientsSplit.Success)
            {
                preIngredientsHtml = fullHtml.Substring(0, ingredientsSplit.Index);

                // Split the ingredients block into the <h2> heading and the list below it
                var raw = ingredientsSplit.Value;
                var headingEnd = raw.IndexOf("</h2>") + "</h2>".Length;
                ingredientsHeadingHtml = raw.Substring(0, headingEnd);
                ingredientsListHtml = raw.Substring(headingEnd);
                scaledIngredientsListHtml = ingredientsListHtml;

                rawPostIngredientsHtml = fullHtml.Substring(ingredientsSplit.Index + ingredientsSplit.Length);
                scaledPostIngredientsHtml = rawPostIngredientsHtml;
            }
            else
            {
                preIngredientsHtml = fullHtml;
                ingredientsHeadingHtml = string.Empty;
                ingredientsListHtml = string.Empty;
                scaledIngredientsListHtml = string.Empty;
                rawPostIngredientsHtml = string.Empty;
                scaledPostIngredientsHtml = string.Empty;
            }
        }
        catch (HttpRequestException)
        {
            errorMessage = $"Kunde inte hitta receptet '{Slug}'. Kontrollera att filen finns i recept-mappen.";
        }
        catch (Exception ex)
        {
            errorMessage = $"Ett fel uppstod: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private void IncrementServings() => SetServings(currentServings + 1);
    private void DecrementServings() => SetServings(currentServings - 1);

    private void OnServingsSelectChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var v))
            SetServings(v);
    }

    private void SetServings(int value)
    {
        currentServings = Math.Clamp(value, 1, 12);
        var factor = (double)currentServings / defaultServings;
        scaledIngredientsListHtml = ScaleIngredientHtml(ingredientsListHtml, factor);
        scaledPostIngredientsHtml = ScaleStepsHtml(rawPostIngredientsHtml, factor);
    }

    private static string ScaleStepsHtml(string html, double factor)
    {
        if (Math.Abs(factor - 1.0) < 0.0001) return html;

        // Only scale numbers inside <strong> tags — ingredients are always bolded in steps
        return Regex.Replace(
            html,
            @"(?s)<strong>(.*?)</strong>",
            m =>
            {
                var scaled = Regex.Replace(m.Groups[1].Value, @"\d+(?:[.,]\d+)?", nm =>
                {
                    var numStr = nm.Value.Replace(',', '.');
                    if (double.TryParse(numStr, System.Globalization.NumberStyles.Any,
                        System.Globalization.CultureInfo.InvariantCulture, out var num))
                        return FormatScaledNumber(num * factor);
                    return nm.Value;
                });
                return $"<strong>{scaled}</strong>";
            });
    }

    private static string ScaleIngredientHtml(string html, double factor)
    {
        if (Math.Abs(factor - 1.0) < 0.0001) return html;

        return Regex.Replace(
            html,
            @"(?s)(</label>)(.*?)(</li>)",
            m =>
            {
                var scaled = Regex.Replace(m.Groups[2].Value, @"\d+(?:[.,]\d+)?", nm =>
                {
                    var numStr = nm.Value.Replace(',', '.');
                    if (double.TryParse(numStr, System.Globalization.NumberStyles.Any,
                        System.Globalization.CultureInfo.InvariantCulture, out var num))
                        return FormatScaledNumber(num * factor);
                    return nm.Value;
                });
                return m.Groups[1].Value + scaled + m.Groups[3].Value;
            });
    }

    private static string FormatScaledNumber(double value)
    {
        if (value == Math.Floor(value))
            return ((long)value).ToString();
        var rounded = Math.Round(value, 1);
        if (rounded == Math.Floor(rounded))
            return ((long)rounded).ToString();
        return rounded.ToString("0.#", System.Globalization.CultureInfo.InvariantCulture);
    }

    private static string InjectStepCircleLabels(string html)
    {
        // Each checkbox gets a unique id; a <label class="step-circle"> is inserted right
        // after it so the CSS adjacent-sibling rule (input:checked + label) can style it.
        int stepIndex = 0;
        return Regex.Replace(
            html,
            @"<li class=""task-list-item""><input type=""checkbox""([^>]*)>",
            m =>
            {
                stepIndex++;
                var id = $"step-{stepIndex}";
                var attrs = m.Groups[1].Value;
                return $"<li class=\"task-list-item\"><input type=\"checkbox\" id=\"{id}\"{attrs}>" +
                       $"<label class=\"step-circle\" for=\"{id}\"></label>";
            });
    }
}

